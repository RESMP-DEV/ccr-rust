# yaml-language-server: $schema=
# CCR-Rust v1.0.0 — Full Replacement
#
# Updated: 2026-02-03
# Status:
#   ❌ CLI subcommands - NOT IMPLEMENTED (only basic args)
#   ❌ Preset namespaces - NOT IMPLEMENTED
#   ❌ Web search - NOT IMPLEMENTED
#   ❌ Docker/K8s - NOT IMPLEMENTED
#
# Run from AlphaHENG repo root:
#   uv run alphaheng tasks add contrib/ccr-rust/tasks/ccr_rust_v10_full.yaml

tasks:
  # ==========================================================================
  # Phase 1: CLI Subcommands (P0)
  # ==========================================================================

  - name: ccr-cli-add-subcommand-derive
    priority: P0
    prompt: |
      Add clap `Subcommand` derive to `contrib/ccr-rust/src/main.rs`.

      Change the Cli struct to support subcommands:

      ```rust
      use clap::{Parser, Subcommand};

      #[derive(Parser)]
      #[command(name = "ccr-rust")]
      #[command(about = "Claude Code Router in Rust")]
      struct Cli {
          #[command(subcommand)]
          command: Option<Commands>,
          
          /// Path to config file (global option)
          #[arg(short, long, env = "CCR_CONFIG", global = true)]
          config: Option<String>,
      }

      #[derive(Subcommand)]
      enum Commands {
          /// Start the server (default)
          Start {
              #[arg(long, default_value = "127.0.0.1")]
              host: String,
              #[arg(short, long, default_value = "3456")]
              port: u16,
              #[arg(long, default_value = "512")]
              max_streams: usize,
          },
          /// Check if server is running
          Status {
              #[arg(long, default_value = "127.0.0.1")]
              host: String,
              #[arg(short, long, default_value = "3456")]
              port: u16,
          },
          /// Validate config file
          Validate,
          /// Show version info
          Version,
      }
      ```
    verify_command: grep -q "enum Commands\|Subcommand" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-extract-run-server
    priority: P0
    dependencies: [ccr-cli-add-subcommand-derive]
    prompt: |
      Extract server startup into `run_server` function in `contrib/ccr-rust/src/main.rs`.

      Move the config loading, state init, and serve logic:

      ```rust
      async fn run_server(
          config_path: &str,
          host: String,
          port: u16,
          max_streams: usize,
      ) -> anyhow::Result<()> {
          let config = Config::from_file(config_path)?;
          tracing::info!("Loaded config from {}", config_path);
          // ... rest of current main() server logic
      }
      ```
    verify_command: grep -q "async fn run_server" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-dispatch-commands
    priority: P0
    dependencies: [ccr-cli-extract-run-server]
    prompt: |
      Add command dispatch in `main()` in `contrib/ccr-rust/src/main.rs`:

      ```rust
      #[tokio::main]
      async fn main() -> Result<()> {
          // ... tracing init ...
          
          let cli = Cli::parse();
          let config_path = cli.config
              .map(|p| shellexpand::tilde(&p).to_string())
              .unwrap_or_else(|| shellexpand::tilde("~/.claude-code-router/config.json").to_string());
          
          match cli.command {
              Some(Commands::Start { host, port, max_streams }) | None => {
                  run_server(&config_path, host.unwrap_or("127.0.0.1".into()), 
                             port.unwrap_or(3456), max_streams.unwrap_or(512)).await?;
              }
              Some(Commands::Status { host, port }) => {
                  check_status(&host, port).await?;
              }
              Some(Commands::Validate) => {
                  validate_config(&config_path)?;
              }
              Some(Commands::Version) => {
                  show_version();
              }
          }
          Ok(())
      }
      ```
    verify_command: grep -q "Commands::Start\|Commands::Status" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-status-impl
    priority: P0
    dependencies: [ccr-cli-dispatch-commands]
    prompt: |
      Implement `check_status` function in `contrib/ccr-rust/src/main.rs`:

      ```rust
      async fn check_status(host: &str, port: u16) -> anyhow::Result<()> {
          let client = reqwest::Client::new();
          let url = format!("http://{}:{}/health", host, port);
          
          match client.get(&url)
              .timeout(std::time::Duration::from_secs(5))
              .send()
              .await
          {
              Ok(resp) if resp.status().is_success() => {
                  println!("✓ CCR-Rust running on {}:{}", host, port);
                  
                  // Fetch latencies
                  let lat_url = format!("http://{}:{}/v1/latencies", host, port);
                  if let Ok(lat_resp) = client.get(&lat_url).send().await {
                      if let Ok(json) = lat_resp.json::<serde_json::Value>().await {
                          println!("Latencies: {}", serde_json::to_string_pretty(&json)?);
                      }
                  }
                  Ok(())
              }
              Ok(resp) => {
                  eprintln!("✗ Server returned: {}", resp.status());
                  std::process::exit(1);
              }
              Err(e) => {
                  eprintln!("✗ Not running: {}", e);
                  std::process::exit(1);
              }
          }
      }
      ```
    verify_command: grep -q "async fn check_status" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-validate-impl
    priority: P0
    dependencies: [ccr-cli-dispatch-commands]
    prompt: |
      Implement `validate_config` function in `contrib/ccr-rust/src/main.rs`:

      ```rust
      fn validate_config(config_path: &str) -> anyhow::Result<()> {
          println!("Validating: {}", config_path);
          
          let config = Config::from_file(config_path)?;
          
          let providers = config.providers();
          println!("✓ {} provider(s)", providers.len());
          for p in providers {
              println!("  - {}: {} model(s)", p.name, p.models.len());
          }
          
          let tiers = config.backend_tiers();
          println!("✓ {} tier(s)", tiers.len());
          for (spec, name) in &tiers {
              println!("  - {}: {}", name, spec);
          }
          
          println!("\n✓ Configuration valid");
          Ok(())
      }
      ```
    verify_command: grep -q "fn validate_config" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-version-impl
    priority: P0
    dependencies: [ccr-cli-dispatch-commands]
    prompt: |
      Implement `show_version` function in `contrib/ccr-rust/src/main.rs`:

      ```rust
      fn show_version() {
          println!("ccr-rust {}", env!("CARGO_PKG_VERSION"));
          #[cfg(debug_assertions)]
          println!("Build: debug");
          #[cfg(not(debug_assertions))]
          println!("Build: release");
          println!("Features: streaming, ewma-routing, transformers");
      }
      ```

      Update Cargo.toml version to 1.0.0:
      ```toml
      [package]
      version = "1.0.0"
      ```
    verify_command: grep -q "fn show_version" contrib/ccr-rust/src/main.rs

  # ==========================================================================
  # Phase 2: Preset Namespaces (P1)
  # ==========================================================================

  - name: ccr-preset-config-struct
    priority: P1
    prompt: |
      Add preset configuration to `contrib/ccr-rust/src/config.rs`:

      ```rust
      #[derive(Debug, Clone, Deserialize, Default)]
      pub struct PresetConfig {
          /// Provider,model to route to
          pub route: String,
          /// Optional max_tokens override
          pub max_tokens: Option<u32>,
          /// Optional temperature override
          pub temperature: Option<f32>,
      }
      ```

      Add to main Config struct:
      ```rust
      #[serde(default)]
      pub presets: HashMap<String, PresetConfig>,
      ```
    verify_command: grep -q "PresetConfig\|presets.*HashMap" contrib/ccr-rust/src/config.rs

  - name: ccr-preset-route-handler
    priority: P1
    dependencies: [ccr-preset-config-struct]
    prompt: |
      Add preset route handler in `contrib/ccr-rust/src/router.rs`:

      ```rust
      pub async fn handle_preset_messages(
          State(state): State<AppState>,
          Path(preset_name): Path<String>,
          Json(request): Json<AnthropicRequest>,
      ) -> Response {
          let preset = match state.config.presets.get(&preset_name) {
              Some(p) => p,
              None => {
                  return (
                      StatusCode::NOT_FOUND,
                      Json(json!({"error": format!("Preset '{}' not found", preset_name)})),
                  ).into_response();
              }
          };
          
          let mut req = request;
          if let Some(mt) = preset.max_tokens {
              req.max_tokens = Some(mt);
          }
          if let Some(temp) = preset.temperature {
              req.temperature = Some(temp);
          }
          
          // Route to preset's specified tier
          // ... handle_messages logic with preset.route as tier-0
      }
      ```
    verify_command: grep -q "handle_preset_messages\|preset_name.*Path" contrib/ccr-rust/src/router.rs

  - name: ccr-preset-route-register
    priority: P1
    dependencies: [ccr-preset-route-handler]
    prompt: |
      Register preset route in `contrib/ccr-rust/src/main.rs`:

      Add to the router:
      ```rust
      let app = Router::new()
          .route("/v1/messages", post(router::handle_messages))
          .route("/preset/:preset_name/v1/messages", post(router::handle_preset_messages))
          // ... other routes
      ```
    verify_command: grep -q "/preset/:preset_name" contrib/ccr-rust/src/main.rs

  - name: ccr-preset-list-endpoint
    priority: P1
    dependencies: [ccr-preset-config-struct]
    prompt: |
      Add `/v1/presets` endpoint in `contrib/ccr-rust/src/router.rs`:

      ```rust
      pub async fn list_presets(State(state): State<AppState>) -> impl IntoResponse {
          let presets: Vec<_> = state.config.presets
              .iter()
              .map(|(name, cfg)| json!({
                  "name": name,
                  "route": cfg.route,
                  "max_tokens": cfg.max_tokens,
                  "temperature": cfg.temperature,
              }))
              .collect();
          Json(presets)
      }
      ```

      Register: `.route("/v1/presets", get(router::list_presets))`
    verify_command: grep -q "list_presets" contrib/ccr-rust/src/router.rs

  # ==========================================================================
  # Phase 3: Web Search (P1)
  # ==========================================================================

  - name: ccr-websearch-config
    priority: P1
    prompt: |
      Add web search config to `contrib/ccr-rust/src/config.rs`:

      ```rust
      #[derive(Debug, Clone, Deserialize, Default)]
      pub struct WebSearchConfig {
          #[serde(default)]
          pub enabled: bool,
          /// Provider,model for search requests
          pub search_provider: Option<String>,
      }
      ```

      Add to Router config:
      ```rust
      #[serde(default)]
      pub web_search: WebSearchConfig,
      ```
    verify_command: grep -q "WebSearchConfig\|search_provider" contrib/ccr-rust/src/config.rs

  - name: ccr-websearch-detect
    priority: P1
    dependencies: [ccr-websearch-config]
    prompt: |
      Add search tag detection in `contrib/ccr-rust/src/router.rs`:

      ```rust
      fn needs_web_search(request: &AnthropicRequest) -> bool {
          for msg in &request.messages {
              if let Some(text) = msg.content.as_str() {
                  if text.contains("[search]") || text.contains("[web]") {
                      return true;
                  }
              }
          }
          false
      }

      fn strip_search_tag(request: &mut AnthropicRequest) {
          for msg in &mut request.messages {
              if let Some(text) = msg.content.as_str() {
                  msg.content = serde_json::Value::String(
                      text.replace("[search]", "").replace("[web]", "").trim().to_string()
                  );
              }
          }
      }
      ```
    verify_command: grep -q "needs_web_search\|\[search\]" contrib/ccr-rust/src/router.rs

  - name: ccr-websearch-route
    priority: P1
    dependencies: [ccr-websearch-detect]
    prompt: |
      Route search requests in `handle_messages` in `contrib/ccr-rust/src/router.rs`:

      At the start of handle_messages, check for search:
      ```rust
      let mut request = request;
      if state.config.router.web_search.enabled && needs_web_search(&request) {
          strip_search_tag(&mut request);
          if let Some(ref search_tier) = state.config.router.web_search.search_provider {
              // Prepend search provider to tier order
              ordered.insert(0, (search_tier.clone(), "search".to_string()));
          }
      }
      ```
    verify_command: grep -q "web_search.enabled\|search_provider" contrib/ccr-rust/src/router.rs

  # ==========================================================================
  # Phase 4: Deployment Files (P2)
  # ==========================================================================

  - name: ccr-deploy-dockerfile
    priority: P2
    prompt: |
      Create `contrib/ccr-rust/Dockerfile`:

      ```dockerfile
      # Build stage
      FROM rust:1.75-bookworm AS builder
      WORKDIR /app
      COPY Cargo.toml Cargo.lock ./
      COPY src ./src
      RUN cargo build --release

      # Runtime
      FROM debian:bookworm-slim
      RUN apt-get update && apt-get install -y ca-certificates && rm -rf /var/lib/apt/lists/*
      RUN useradd -r -u 1000 ccr
      COPY --from=builder /app/target/release/ccr-rust /usr/local/bin/
      USER ccr
      EXPOSE 3456
      HEALTHCHECK --interval=30s --timeout=5s CMD curl -f http://localhost:3456/health || exit 1
      ENTRYPOINT ["ccr-rust"]
      CMD ["start", "--host", "0.0.0.0"]
      ```
    verify_command: test -f contrib/ccr-rust/Dockerfile

  - name: ccr-deploy-compose
    priority: P2
    dependencies: [ccr-deploy-dockerfile]
    prompt: |
      Create `contrib/ccr-rust/docker-compose.yml`:

      ```yaml
      version: '3.8'
      services:
        ccr-rust:
          build: .
          ports:
            - "3456:3456"
          volumes:
            - ./config.json:/etc/ccr/config.json:ro
          environment:
            - RUST_LOG=info
            - CCR_CONFIG=/etc/ccr/config.json
          restart: unless-stopped
          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:3456/health"]
            interval: 30s
            timeout: 5s
            retries: 3
      ```
    verify_command: test -f contrib/ccr-rust/docker-compose.yml

  - name: ccr-deploy-systemd
    priority: P2
    prompt: |
      Create `contrib/ccr-rust/deploy/ccr-rust.service`:

      ```ini
      [Unit]
      Description=Claude Code Router (Rust)
      After=network-online.target

      [Service]
      Type=simple
      User=ccr
      ExecStart=/usr/local/bin/ccr-rust start --config /etc/ccr/config.json --host 0.0.0.0
      Restart=always
      RestartSec=5
      Environment=RUST_LOG=info

      [Install]
      WantedBy=multi-user.target
      ```
    verify_command: test -f contrib/ccr-rust/deploy/ccr-rust.service

  - name: ccr-deploy-launchd
    priority: P2
    prompt: |
      Create `contrib/ccr-rust/deploy/com.ccr.rust.plist` for macOS:

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0">
      <dict>
          <key>Label</key>
          <string>com.ccr.rust</string>
          <key>ProgramArguments</key>
          <array>
              <string>/usr/local/bin/ccr-rust</string>
              <string>start</string>
              <string>--config</string>
              <string>/Users/Shared/.claude-code-router/config.json</string>
          </array>
          <key>RunAtLoad</key>
          <true/>
          <key>KeepAlive</key>
          <true/>
          <key>StandardOutPath</key>
          <string>/usr/local/var/log/ccr-rust.log</string>
          <key>StandardErrorPath</key>
          <string>/usr/local/var/log/ccr-rust.err</string>
      </dict>
      </plist>
      ```
    verify_command: test -f contrib/ccr-rust/deploy/com.ccr.rust.plist

  # ==========================================================================
  # Phase 5: Kubernetes (P2)
  # ==========================================================================

  - name: ccr-k8s-deployment
    priority: P2
    prompt: |
      Create `contrib/ccr-rust/k8s/deployment.yaml`:

      ```yaml
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ccr-rust
      spec:
        replicas: 2
        selector:
          matchLabels:
            app: ccr-rust
        template:
          metadata:
            labels:
              app: ccr-rust
            annotations:
              prometheus.io/scrape: "true"
              prometheus.io/port: "3456"
          spec:
            containers:
              - name: ccr-rust
                image: ghcr.io/resmp-dev/ccr-rust:latest
                ports:
                  - containerPort: 3456
                env:
                  - name: RUST_LOG
                    value: "info"
                  - name: CCR_CONFIG
                    value: "/etc/ccr/config.json"
                resources:
                  requests:
                    memory: "64Mi"
                    cpu: "100m"
                  limits:
                    memory: "256Mi"
                    cpu: "500m"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 3456
                  initialDelaySeconds: 5
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 3456
                volumeMounts:
                  - name: config
                    mountPath: /etc/ccr
            volumes:
              - name: config
                configMap:
                  name: ccr-rust-config
      ```
    verify_command: test -f contrib/ccr-rust/k8s/deployment.yaml

  - name: ccr-k8s-service
    priority: P2
    dependencies: [ccr-k8s-deployment]
    prompt: |
      Create `contrib/ccr-rust/k8s/service.yaml`:

      ```yaml
      apiVersion: v1
      kind: Service
      metadata:
        name: ccr-rust
      spec:
        type: ClusterIP
        ports:
          - port: 3456
            targetPort: 3456
        selector:
          app: ccr-rust
      ```
    verify_command: test -f contrib/ccr-rust/k8s/service.yaml

  - name: ccr-k8s-configmap
    priority: P2
    dependencies: [ccr-k8s-deployment]
    prompt: |
      Create `contrib/ccr-rust/k8s/configmap.yaml`:

      ```yaml
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: ccr-rust-config
      data:
        config.json: |
          {
            "Providers": [],
            "Router": {"default": ""}
          }
      ```
    verify_command: test -f contrib/ccr-rust/k8s/configmap.yaml

  # ==========================================================================
  # Phase 6: Documentation (P2)
  # ==========================================================================

  - name: ccr-docs-cli
    priority: P2
    dependencies: [ccr-cli-version-impl]
    prompt: |
      Create `contrib/ccr-rust/docs/cli.md`:

      # CLI Reference

      ## Commands

      ### `ccr-rust start`
      Start the server (default).
      ```
      ccr-rust start [--host 127.0.0.1] [--port 3456] [--max-streams 512]
      ```

      ### `ccr-rust status`
      Check if server is running.
      ```
      ccr-rust status [--host 127.0.0.1] [--port 3456]
      ```

      ### `ccr-rust validate`
      Validate configuration.
      ```
      ccr-rust validate
      ```

      ### `ccr-rust version`
      Show version info.

      ## Global Options

      - `--config, -c` - Config file path (env: CCR_CONFIG)

      ## Examples

      ```bash
      ccr-rust start --port 8080
      ccr-rust status
      ccr-rust validate --config ~/custom.json
      ```
    verify_command: test -f contrib/ccr-rust/docs/cli.md

  - name: ccr-docs-presets
    priority: P2
    dependencies: [ccr-preset-list-endpoint]
    prompt: |
      Create `contrib/ccr-rust/docs/presets.md`:

      # Presets

      Named configurations for quick routing.

      ## Config

      ```json
      {
        "presets": {
          "fast": {"route": "groq,llama-3", "max_tokens": 2048},
          "smart": {"route": "anthropic,claude-3-opus"}
        }
      }
      ```

      ## Usage

      ```bash
      curl http://localhost:3456/preset/fast/v1/messages ...
      ```

      ## Listing

      ```bash
      curl http://localhost:3456/v1/presets
      ```
    verify_command: test -f contrib/ccr-rust/docs/presets.md

  # ==========================================================================
  # Phase 7: CI/CD (P3)
  # ==========================================================================

  - name: ccr-github-ci
    priority: P3
    prompt: |
      Create `contrib/ccr-rust/.github/workflows/ci.yml`:

      ```yaml
      name: CI
      on: [push, pull_request]
      jobs:
        test:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4
            - uses: dtolnay/rust-toolchain@stable
            - uses: Swatinem/rust-cache@v2
            - run: cargo test
            - run: cargo clippy -- -D warnings
            - run: cargo fmt --check
      ```
    verify_command: test -f contrib/ccr-rust/.github/workflows/ci.yml

  - name: ccr-github-release
    priority: P3
    dependencies: [ccr-github-ci]
    prompt: |
      Create `contrib/ccr-rust/.github/workflows/release.yml`:

      ```yaml
      name: Release
      on:
        push:
          tags: ['v*']
      jobs:
        build:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4
            - uses: dtolnay/rust-toolchain@stable
            - run: cargo build --release
            - uses: softprops/action-gh-release@v1
              with:
                files: target/release/ccr-rust
      ```
    verify_command: test -f contrib/ccr-rust/.github/workflows/release.yml

  # ==========================================================================
  # Phase 8: README Update (P3)
  # ==========================================================================

  - name: ccr-readme-v1-update
    priority: P3
    prompt: |
      Update `contrib/ccr-rust/README.md` roadmap section.

      Replace the Roadmap section with:

      ## What's Implemented

      ### ✅ Core (v0.1.0)
      - Zero-copy SSE streaming
      - Multi-tier cascade with EWMA routing
      - Token drift verification
      - Prometheus metrics

      ### ✅ Format Parity (v0.2.0)  
      - OpenAI ↔ Anthropic translation
      - Reasoning model support
      - Transformer infrastructure

      ### ✅ Production (v0.3.0)
      - Graceful shutdown
      - Rate limit handling
      - Think-tag stripping

      ### ✅ Full Feature (v1.0.0)
      - CLI subcommands
      - Preset namespaces
      - Web search integration
      - Docker/Kubernetes deployment

      ## Installation

      ```bash
      # From source
      cargo install --path .
      ccr-rust start

      # Docker
      docker run -v ./config.json:/etc/ccr/config.json ghcr.io/resmp-dev/ccr-rust
      ```
    verify_command: grep -q "Full Feature (v1.0.0)" contrib/ccr-rust/README.md
