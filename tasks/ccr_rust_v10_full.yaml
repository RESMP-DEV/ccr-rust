# yaml-language-server: $schema=
# CCR-Rust v1.0.0 — Full Feature Set
#
# Updated: 2026-02-03
#
# Status after v0.3.0:
#   ✅ EWMA routing, streaming, metrics
#   ✅ OpenAI↔Anthropic translation
#   ✅ Rate limiting, graceful shutdown
#   ✅ Think-tag stripping, tool results
#
# Remaining for v1.0.0:
#   ❌ CLI subcommands (start/status/validate/version)
#   ❌ Preset namespaces
#   ❌ Web search routing
#   ❌ Docker/K8s deployment files
#   ❌ CI/CD workflows
#
# Total: 31 atomic tasks
#
# Run: uv run alphaheng tasks add contrib/ccr-rust/tasks/ccr_rust_v10_full.yaml

tasks:
  # ==========================================================================
  # Phase 1: CLI Infrastructure (P0)
  # ==========================================================================

  - name: ccr-cli-commands-enum
    priority: P0
    prompt: |
      Add `Commands` enum to `contrib/ccr-rust/src/main.rs`.

      Add the Subcommand derive and enum AFTER the existing Cli struct:

      ```rust
      use clap::{Parser, Subcommand};

      #[derive(Subcommand)]
      enum Commands {
          /// Start the server (default if no command given)
          Start {
              #[arg(long, default_value = "127.0.0.1")]
              host: String,
              #[arg(short, long, default_value = "3456")]
              port: u16,
              #[arg(long, default_value = "512")]
              max_streams: usize,
          },
          /// Check if server is running
          Status {
              #[arg(long, default_value = "127.0.0.1")]
              host: String,
              #[arg(short, long, default_value = "3456")]
              port: u16,
          },
          /// Validate config file syntax and providers
          Validate,
          /// Show version and build info
          Version,
      }
      ```
    verify_command: grep -q "enum Commands" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-add-subcommand-field
    priority: P0
    dependencies: [ccr-cli-commands-enum]
    prompt: |
      Add subcommand field to existing Cli struct in `contrib/ccr-rust/src/main.rs`.

      Modify the existing Cli struct to add:
      ```rust
      #[derive(Parser)]
      #[command(name = "ccr-rust")]
      #[command(about = "Claude Code Router in Rust")]
      struct Cli {
          #[command(subcommand)]
          command: Option<Commands>,
          
          /// Path to config file (global option)
          #[arg(short, long, env = "CCR_CONFIG", global = true)]
          config: Option<String>,
      }
      ```

      Remove the old host/port/max_streams fields from Cli 
      (they're now in Commands::Start).
    verify_command: grep -q "command.*Option<Commands>" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-run-server-fn
    priority: P0
    dependencies: [ccr-cli-add-subcommand-field]
    prompt: |
      Extract server logic into `run_server` function in `contrib/ccr-rust/src/main.rs`.

      Move the current main() body (config loading, state init, serve) into:

      ```rust
      async fn run_server(
          config_path: &str,
          host: String,
          port: u16,
          max_streams: usize,
      ) -> anyhow::Result<()> {
          let config = Config::from_file(config_path)?;
          tracing::info!("Loaded config from {}", config_path);
          tracing::info!("Tier order: {:?}", config.backend_tiers());
          tracing::info!("Max concurrent streams: {}", max_streams);
          
          // ... existing ewma_tracker, transformer_registry, state, app, listener code ...
          
          let addr = SocketAddr::from((host.parse::<std::net::IpAddr>()?, port));
          tracing::info!("CCR-Rust listening on {}", addr);
          
          let listener = tokio::net::TcpListener::bind(addr).await?;
          axum::serve(listener, app)
              .with_graceful_shutdown(shutdown_signal())
              .await?;
          
          Ok(())
      }
      ```
    verify_command: grep -q "async fn run_server" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-check-status-fn
    priority: P0
    dependencies: [ccr-cli-run-server-fn]
    prompt: |
      Add `check_status` function to `contrib/ccr-rust/src/main.rs`:

      ```rust
      async fn check_status(host: &str, port: u16) -> anyhow::Result<()> {
          let client = reqwest::Client::new();
          let url = format!("http://{}:{}/health", host, port);
          
          match client.get(&url)
              .timeout(std::time::Duration::from_secs(5))
              .send()
              .await
          {
              Ok(resp) if resp.status().is_success() => {
                  println!("✓ CCR-Rust running on {}:{}", host, port);
                  
                  // Fetch latencies
                  let lat_url = format!("http://{}:{}/v1/latencies", host, port);
                  if let Ok(lat_resp) = client.get(&lat_url).send().await {
                      if let Ok(json) = lat_resp.json::<serde_json::Value>().await {
                          println!("Latencies: {}", serde_json::to_string_pretty(&json)?);
                      }
                  }
                  Ok(())
              }
              Ok(resp) => {
                  eprintln!("✗ Server returned: {}", resp.status());
                  std::process::exit(1);
              }
              Err(e) => {
                  eprintln!("✗ Not running: {}", e);
                  std::process::exit(1);
              }
          }
      }
      ```
    verify_command: grep -q "async fn check_status" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-validate-config-fn
    priority: P0
    dependencies: [ccr-cli-run-server-fn]
    prompt: |
      Add `validate_config` function to `contrib/ccr-rust/src/main.rs`:

      ```rust
      fn validate_config(config_path: &str) -> anyhow::Result<()> {
          println!("Validating: {}", config_path);
          
          let config = Config::from_file(config_path)?;
          
          let providers = config.providers();
          println!("✓ {} provider(s)", providers.len());
          for p in providers {
              println!("  - {}: {} model(s)", p.name, p.models.len());
          }
          
          let tiers = config.backend_tiers();
          println!("✓ {} tier(s)", tiers.len());
          for (spec, name) in &tiers {
              println!("  - {}: {}", name, spec);
          }
          
          println!("\n✓ Configuration valid");
          Ok(())
      }
      ```
    verify_command: grep -q "fn validate_config" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-show-version-fn
    priority: P0
    dependencies: [ccr-cli-run-server-fn]
    prompt: |
      Add `show_version` function to `contrib/ccr-rust/src/main.rs`:

      ```rust
      fn show_version() {
          println!("ccr-rust {}", env!("CARGO_PKG_VERSION"));
          #[cfg(debug_assertions)]
          println!("Build: debug");
          #[cfg(not(debug_assertions))]
          println!("Build: release");
          println!("Features: streaming, ewma-routing, transformers, rate-limiting");
      }
      ```
    verify_command: grep -q "fn show_version" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-main-dispatch
    priority: P0
    dependencies:
      [
        ccr-cli-check-status-fn,
        ccr-cli-validate-config-fn,
        ccr-cli-show-version-fn,
      ]
    prompt: |
      Update `main()` in `contrib/ccr-rust/src/main.rs` to dispatch commands:

      ```rust
      #[tokio::main]
      async fn main() -> Result<()> {
          tracing_subscriber::registry()
              .with(
                  tracing_subscriber::EnvFilter::try_from_default_env()
                      .unwrap_or_else(|_| "ccr_rust=info,tower_http=debug".into()),
              )
              .with(tracing_subscriber::fmt::layer())
              .init();
          
          let cli = Cli::parse();
          let config_path = cli.config
              .map(|p| shellexpand::tilde(&p).to_string())
              .unwrap_or_else(|| shellexpand::tilde("~/.claude-code-router/config.json").to_string());
          
          match cli.command {
              Some(Commands::Start { host, port, max_streams }) => {
                  run_server(&config_path, host, port, max_streams).await?;
              }
              None => {
                  // Default: start server with defaults
                  run_server(&config_path, "127.0.0.1".into(), 3456, 512).await?;
              }
              Some(Commands::Status { host, port }) => {
                  check_status(&host, port).await?;
              }
              Some(Commands::Validate) => {
                  validate_config(&config_path)?;
              }
              Some(Commands::Version) => {
                  show_version();
              }
          }
          Ok(())
      }
      ```
    verify_command: grep -q "Commands::Start\|Commands::Status" contrib/ccr-rust/src/main.rs

  - name: ccr-cli-bump-version
    priority: P0
    dependencies: [ccr-cli-main-dispatch]
    prompt: |
      Update version in `contrib/ccr-rust/Cargo.toml` to 1.0.0:

      Change the version line under [package]:
      ```toml
      [package]
      name = "ccr-rust"
      version = "1.0.0"
      ```
    verify_command: grep -q 'version = "1.0.0"' contrib/ccr-rust/Cargo.toml

  # ==========================================================================
  # Phase 2: Preset Config (P1)
  # ==========================================================================

  - name: ccr-preset-struct
    priority: P1
    prompt: |
      Add `PresetConfig` struct to `contrib/ccr-rust/src/config.rs`:

      ```rust
      /// Named routing preset with optional parameter overrides.
      #[derive(Debug, Clone, Deserialize, Default)]
      pub struct PresetConfig {
          /// Provider,model to route to (e.g., "anthropic,claude-3-opus")
          pub route: String,
          /// Optional max_tokens override
          #[serde(default)]
          pub max_tokens: Option<u32>,
          /// Optional temperature override
          #[serde(default)]
          pub temperature: Option<f32>,
      }
      ```
    verify_command: grep -q "struct PresetConfig" contrib/ccr-rust/src/config.rs

  - name: ccr-preset-add-to-config
    priority: P1
    dependencies: [ccr-preset-struct]
    prompt: |
      Add `presets` field to main Config struct in `contrib/ccr-rust/src/config.rs`:

      Find the Config struct and add:
      ```rust
      #[serde(default)]
      pub presets: HashMap<String, PresetConfig>,
      ```

      Also add the import if needed:
      ```rust
      use std::collections::HashMap;
      ```
    verify_command: grep -q "presets.*HashMap.*PresetConfig" contrib/ccr-rust/src/config.rs

  - name: ccr-preset-accessor
    priority: P1
    dependencies: [ccr-preset-add-to-config]
    prompt: |
      Add preset accessor method to Config in `contrib/ccr-rust/src/config.rs`:

      ```rust
      impl Config {
          /// Get a preset by name.
          pub fn get_preset(&self, name: &str) -> Option<&PresetConfig> {
              self.presets.get(name)
          }
          
          /// List all preset names.
          pub fn preset_names(&self) -> Vec<&str> {
              self.presets.keys().map(|s| s.as_str()).collect()
          }
      }
      ```
    verify_command: grep -q "fn get_preset\|fn preset_names" contrib/ccr-rust/src/config.rs

  # ==========================================================================
  # Phase 3: Preset Routes (P1)
  # ==========================================================================

  - name: ccr-preset-list-handler
    priority: P1
    dependencies: [ccr-preset-accessor]
    prompt: |
      Add `/v1/presets` list endpoint in `contrib/ccr-rust/src/router.rs`:

      ```rust
      /// List all configured presets.
      pub async fn list_presets(State(state): State<AppState>) -> impl IntoResponse {
          let presets: Vec<_> = state.config.presets
              .iter()
              .map(|(name, cfg)| serde_json::json!({
                  "name": name,
                  "route": cfg.route,
                  "max_tokens": cfg.max_tokens,
                  "temperature": cfg.temperature,
              }))
              .collect();
          Json(presets)
      }
      ```
    verify_command: grep -q "pub async fn list_presets" contrib/ccr-rust/src/router.rs

  - name: ccr-preset-messages-handler
    priority: P1
    dependencies: [ccr-preset-list-handler]
    prompt: |
      Add `/preset/:name/v1/messages` handler in `contrib/ccr-rust/src/router.rs`:

      ```rust
      use axum::extract::Path;

      /// Handle messages via a named preset.
      pub async fn handle_preset_messages(
          State(state): State<AppState>,
          Path(preset_name): Path<String>,
          Json(mut request): Json<AnthropicRequest>,
      ) -> Response {
          let preset = match state.config.get_preset(&preset_name) {
              Some(p) => p,
              None => {
                  return (
                      StatusCode::NOT_FOUND,
                      Json(serde_json::json!({"error": format!("Preset '{}' not found", preset_name)})),
                  ).into_response();
              }
          };
          
          // Apply preset overrides
          if let Some(mt) = preset.max_tokens {
              request.max_tokens = Some(mt);
          }
          if let Some(temp) = preset.temperature {
              request.temperature = Some(temp);
          }
          
          // Force route to preset's tier
          request.model = preset.route.clone();
          
          // Delegate to normal handler
          handle_messages(State(state), Json(request)).await
      }
      ```
    verify_command: grep -q "pub async fn handle_preset_messages" contrib/ccr-rust/src/router.rs

  - name: ccr-preset-register-routes
    priority: P1
    dependencies: [ccr-preset-messages-handler]
    prompt: |
      Register preset routes in `contrib/ccr-rust/src/main.rs`:

      Add to the Router::new() chain:
      ```rust
      let app = Router::new()
          .route("/v1/messages", post(router::handle_messages))
          .route("/v1/presets", get(router::list_presets))
          .route("/preset/:preset_name/v1/messages", post(router::handle_preset_messages))
          // ... rest of routes
      ```
    verify_command: grep -q "/preset/:preset_name" contrib/ccr-rust/src/main.rs

  # ==========================================================================
  # Phase 4: Web Search Config (P1)
  # ==========================================================================

  - name: ccr-websearch-struct
    priority: P1
    prompt: |
      Add `WebSearchConfig` struct to `contrib/ccr-rust/src/config.rs`:

      ```rust
      /// Configuration for web search routing.
      #[derive(Debug, Clone, Deserialize, Default)]
      pub struct WebSearchConfig {
          /// Enable [search] tag detection
          #[serde(default)]
          pub enabled: bool,
          /// Provider,model for search-enabled requests
          pub search_provider: Option<String>,
      }
      ```
    verify_command: grep -q "struct WebSearchConfig" contrib/ccr-rust/src/config.rs

  - name: ccr-websearch-add-to-router-config
    priority: P1
    dependencies: [ccr-websearch-struct]
    prompt: |
      Add `web_search` field to RouterConfig in `contrib/ccr-rust/src/config.rs`:

      Find the RouterConfig struct and add:
      ```rust
      #[serde(default)]
      pub web_search: WebSearchConfig,
      ```
    verify_command: grep -q "web_search.*WebSearchConfig" contrib/ccr-rust/src/config.rs

  # ==========================================================================
  # Phase 5: Web Search Logic (P1)
  # ==========================================================================

  - name: ccr-websearch-needs-fn
    priority: P1
    dependencies: [ccr-websearch-add-to-router-config]
    prompt: |
      Add `needs_web_search` function in `contrib/ccr-rust/src/router.rs`:

      ```rust
      /// Check if request contains [search] or [web] tags.
      fn needs_web_search(request: &AnthropicRequest) -> bool {
          for msg in &request.messages {
              if let Some(text) = msg.content.as_str() {
                  if text.contains("[search]") || text.contains("[web]") {
                      return true;
                  }
              }
          }
          false
      }
      ```
    verify_command: grep -q "fn needs_web_search" contrib/ccr-rust/src/router.rs

  - name: ccr-websearch-strip-fn
    priority: P1
    dependencies: [ccr-websearch-needs-fn]
    prompt: |
      Add `strip_search_tags` function in `contrib/ccr-rust/src/router.rs`:

      ```rust
      /// Remove [search] and [web] tags from message content.
      fn strip_search_tags(request: &mut AnthropicRequest) {
          for msg in &mut request.messages {
              if let Some(text) = msg.content.as_str() {
                  let cleaned = text
                      .replace("[search]", "")
                      .replace("[web]", "")
                      .trim()
                      .to_string();
                  msg.content = serde_json::Value::String(cleaned);
              }
          }
      }
      ```
    verify_command: grep -q "fn strip_search_tags" contrib/ccr-rust/src/router.rs

  - name: ccr-websearch-integrate
    priority: P1
    dependencies: [ccr-websearch-strip-fn]
    prompt: |
      Integrate web search in `handle_messages` in `contrib/ccr-rust/src/router.rs`:

      At the start of handle_messages, BEFORE tier ordering, add:
      ```rust
      let mut request = request;
      let mut ordered = state.ewma_tracker.sort_tiers(&tiers);

      // Check for web search
      if state.config.router().web_search.enabled && needs_web_search(&request) {
          strip_search_tags(&mut request);
          if let Some(ref search_provider) = state.config.router().web_search.search_provider {
              // Prepend search provider as first tier
              ordered.insert(0, (search_provider.clone(), "search".to_string()));
              tracing::info!("Web search enabled, prepending {}", search_provider);
          }
      }
      ```
    verify_command: grep -q "web_search.enabled\|search_provider" contrib/ccr-rust/src/router.rs

  # ==========================================================================
  # Phase 6: Deployment - Docker (P2)
  # ==========================================================================

  - name: ccr-deploy-dockerfile
    priority: P2
    prompt: |
      Create `contrib/ccr-rust/Dockerfile`:

      ```dockerfile
      # Build stage
      FROM rust:1.75-bookworm AS builder
      WORKDIR /app
      COPY Cargo.toml Cargo.lock ./
      COPY src ./src
      RUN cargo build --release

      # Runtime stage
      FROM debian:bookworm-slim
      RUN apt-get update && apt-get install -y ca-certificates curl && rm -rf /var/lib/apt/lists/*
      RUN useradd -r -u 1000 ccr
      COPY --from=builder /app/target/release/ccr-rust /usr/local/bin/
      USER ccr
      EXPOSE 3456
      HEALTHCHECK --interval=30s --timeout=5s CMD curl -f http://localhost:3456/health || exit 1
      ENTRYPOINT ["ccr-rust"]
      CMD ["start", "--host", "0.0.0.0"]
      ```
    verify_command: test -f contrib/ccr-rust/Dockerfile

  - name: ccr-deploy-compose
    priority: P2
    dependencies: [ccr-deploy-dockerfile]
    prompt: |
      Create `contrib/ccr-rust/docker-compose.yml`:

      ```yaml
      version: '3.8'
      services:
        ccr-rust:
          build: .
          ports:
            - "3456:3456"
          volumes:
            - ./config.json:/etc/ccr/config.json:ro
          environment:
            - RUST_LOG=info
            - CCR_CONFIG=/etc/ccr/config.json
          restart: unless-stopped
          healthcheck:
            test: ["CMD", "curl", "-f", "http://localhost:3456/health"]
            interval: 30s
            timeout: 5s
            retries: 3
      ```
    verify_command: test -f contrib/ccr-rust/docker-compose.yml

  # ==========================================================================
  # Phase 7: Deployment - Systemd/Launchd (P2)
  # ==========================================================================

  - name: ccr-deploy-systemd
    priority: P2
    prompt: |
      Create `contrib/ccr-rust/deploy/ccr-rust.service`:

      ```ini
      [Unit]
      Description=Claude Code Router (Rust)
      After=network-online.target

      [Service]
      Type=simple
      User=ccr
      ExecStart=/usr/local/bin/ccr-rust start --config /etc/ccr/config.json --host 0.0.0.0
      Restart=always
      RestartSec=5
      Environment=RUST_LOG=info

      [Install]
      WantedBy=multi-user.target
      ```
    verify_command: test -f contrib/ccr-rust/deploy/ccr-rust.service

  - name: ccr-deploy-launchd
    priority: P2
    prompt: |
      Create `contrib/ccr-rust/deploy/com.ccr.rust.plist`:

      ```xml
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0">
      <dict>
          <key>Label</key>
          <string>com.ccr.rust</string>
          <key>ProgramArguments</key>
          <array>
              <string>/usr/local/bin/ccr-rust</string>
              <string>start</string>
              <string>--config</string>
              <string>/Users/Shared/.claude-code-router/config.json</string>
          </array>
          <key>RunAtLoad</key>
          <true/>
          <key>KeepAlive</key>
          <true/>
          <key>StandardOutPath</key>
          <string>/usr/local/var/log/ccr-rust.log</string>
          <key>StandardErrorPath</key>
          <string>/usr/local/var/log/ccr-rust.err</string>
      </dict>
      </plist>
      ```
    verify_command: test -f contrib/ccr-rust/deploy/com.ccr.rust.plist

  # ==========================================================================
  # Phase 8: Deployment - Kubernetes (P2)
  # ==========================================================================

  - name: ccr-k8s-deployment
    priority: P2
    prompt: |
      Create `contrib/ccr-rust/k8s/deployment.yaml`:

      ```yaml
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: ccr-rust
      spec:
        replicas: 2
        selector:
          matchLabels:
            app: ccr-rust
        template:
          metadata:
            labels:
              app: ccr-rust
            annotations:
              prometheus.io/scrape: "true"
              prometheus.io/port: "3456"
          spec:
            containers:
              - name: ccr-rust
                image: ghcr.io/resmp-dev/ccr-rust:latest
                ports:
                  - containerPort: 3456
                env:
                  - name: RUST_LOG
                    value: "info"
                  - name: CCR_CONFIG
                    value: "/etc/ccr/config.json"
                resources:
                  requests:
                    memory: "64Mi"
                    cpu: "100m"
                  limits:
                    memory: "256Mi"
                    cpu: "500m"
                livenessProbe:
                  httpGet:
                    path: /health
                    port: 3456
                  initialDelaySeconds: 5
                readinessProbe:
                  httpGet:
                    path: /health
                    port: 3456
                volumeMounts:
                  - name: config
                    mountPath: /etc/ccr
            volumes:
              - name: config
                configMap:
                  name: ccr-rust-config
      ```
    verify_command: test -f contrib/ccr-rust/k8s/deployment.yaml

  - name: ccr-k8s-service
    priority: P2
    dependencies: [ccr-k8s-deployment]
    prompt: |
      Create `contrib/ccr-rust/k8s/service.yaml`:

      ```yaml
      apiVersion: v1
      kind: Service
      metadata:
        name: ccr-rust
      spec:
        type: ClusterIP
        ports:
          - port: 3456
            targetPort: 3456
        selector:
          app: ccr-rust
      ```
    verify_command: test -f contrib/ccr-rust/k8s/service.yaml

  - name: ccr-k8s-configmap
    priority: P2
    dependencies: [ccr-k8s-deployment]
    prompt: |
      Create `contrib/ccr-rust/k8s/configmap.yaml`:

      ```yaml
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: ccr-rust-config
      data:
        config.json: |
          {
            "Providers": [],
            "Router": {"default": ""}
          }
      ```
    verify_command: test -f contrib/ccr-rust/k8s/configmap.yaml

  # ==========================================================================
  # Phase 9: Documentation (P2)
  # ==========================================================================

  - name: ccr-docs-cli
    priority: P2
    dependencies: [ccr-cli-main-dispatch]
    prompt: |
      Create `contrib/ccr-rust/docs/cli.md`:

      ```markdown
      # CLI Reference

      ## Commands

      ### `ccr-rust start`
      Start the server (default if no command given).
      ```
      ccr-rust start [--host 127.0.0.1] [--port 3456] [--max-streams 512]
      ```

      ### `ccr-rust status`
      Check if server is running.
      ```
      ccr-rust status [--host 127.0.0.1] [--port 3456]
      ```

      ### `ccr-rust validate`
      Validate configuration file.
      ```
      ccr-rust validate
      ```

      ### `ccr-rust version`
      Show version info.

      ## Global Options

      - `--config, -c` - Config file path (env: CCR_CONFIG)

      ## Examples

      ```bash
      ccr-rust start --port 8080
      ccr-rust status
      ccr-rust validate --config ~/custom.json
      ```
      ```
    verify_command: test -f contrib/ccr-rust/docs/cli.md

  - name: ccr-docs-presets
    priority: P2
    dependencies: [ccr-preset-register-routes]
    prompt: |
      Create `contrib/ccr-rust/docs/presets.md`:

      ```markdown
      # Presets

      Named configurations for quick routing.

      ## Configuration

      ```json
      {
        "presets": {
          "fast": {"route": "groq,llama-3", "max_tokens": 2048},
          "smart": {"route": "anthropic,claude-3-opus"}
        }
      }
      ```

      ## Usage

      ```bash
      curl http://localhost:3456/preset/fast/v1/messages \
        -H "Content-Type: application/json" \
        -d '{"messages": [{"role": "user", "content": "Hello"}]}'
      ```

      ## Listing Presets

      ```bash
      curl http://localhost:3456/v1/presets
      ```
      ```
    verify_command: test -f contrib/ccr-rust/docs/presets.md

  # ==========================================================================
  # Phase 10: CI/CD (P3)
  # ==========================================================================

  - name: ccr-github-ci
    priority: P3
    prompt: |
      Create `contrib/ccr-rust/.github/workflows/ci.yml`:

      ```yaml
      name: CI
      on: [push, pull_request]
      jobs:
        test:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4
            - uses: dtolnay/rust-toolchain@stable
            - uses: Swatinem/rust-cache@v2
            - run: cargo test
            - run: cargo clippy -- -D warnings
            - run: cargo fmt --check
      ```
    verify_command: test -f contrib/ccr-rust/.github/workflows/ci.yml

  - name: ccr-github-release
    priority: P3
    dependencies: [ccr-github-ci]
    prompt: |
      Create `contrib/ccr-rust/.github/workflows/release.yml`:

      ```yaml
      name: Release
      on:
        push:
          tags: ['v*']
      jobs:
        build:
          runs-on: ubuntu-latest
          steps:
            - uses: actions/checkout@v4
            - uses: dtolnay/rust-toolchain@stable
            - run: cargo build --release
            - uses: softprops/action-gh-release@v1
              with:
                files: target/release/ccr-rust
      ```
    verify_command: test -f contrib/ccr-rust/.github/workflows/release.yml

  # ==========================================================================
  # Phase 11: README Update (P3)
  # ==========================================================================

  - name: ccr-readme-v1-update
    priority: P3
    dependencies: [ccr-cli-bump-version]
    prompt: |
      Update `contrib/ccr-rust/README.md` roadmap section.

      Replace the Roadmap section with What's Implemented:

      ```markdown
      ## What's Implemented

      ### ✅ Core (v0.1.0)
      - Zero-copy SSE streaming
      - Multi-tier cascade with EWMA routing
      - Token drift verification
      - Prometheus metrics

      ### ✅ Format Parity (v0.2.0)  
      - OpenAI ↔ Anthropic translation
      - Reasoning model support
      - Transformer infrastructure

      ### ✅ Production (v0.3.0)
      - Graceful shutdown
      - Rate limit handling
      - Think-tag stripping

      ### ✅ Full Feature (v1.0.0)
      - CLI subcommands (start/status/validate/version)
      - Preset namespaces
      - Web search integration
      - Docker/Kubernetes deployment

      ## Installation

      ```bash
      # From source
      cargo install --path .
      ccr-rust start

      # Docker
      docker run -v ./config.json:/etc/ccr/config.json ghcr.io/resmp-dev/ccr-rust
      ```
      ```
    verify_command: grep -q "Full Feature (v1.0.0)" contrib/ccr-rust/README.md
